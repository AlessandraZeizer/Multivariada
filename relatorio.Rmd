---
title: Análise de Agrupamento com o Pacote *Cluster*
author: |-
    | Daniel Ikenaga^[Universidade Federal do Paraná]
    | Francielle Przibiciem$^{*}$
    | Paula Alessandra Zeizer Dimas$^{*}$
abstract: |
  Este relatório tem por objetivo principal mostrar mostrar algumas funções 
  do pacote *Cluster*. A Análise de Cluster é uma técnica multivariada que tem por objetivo agrupar n observações em gruposd de indivíduos similares com relação a determinadas variáveis. Dados do IPARDES foram utilizados para exemplificar
  resultados e gráficos.
output: 
    pdf_document:
        #geometry: margin=0.6in
---

```{r setup, include=FALSE}
library(knitr)
library(lattice)
library(car)
library(readxl)
opts_chunk$set(cache=TRUE, cache.path="cache/", fig.path="graphs/", 
               dpi=100, fig.align="center", fig.pos="hold", 
               fig.width=5, fig.height=4, null_prefix=TRUE,
               comment=NA, warning=FALSE, error=FALSE, message=FALSE)
# A killPrefix hook.
default_output_hook <- knitr::knit_hooks$get("output")
knitr::knit_hooks$set( output = function(x, options) {

  comment <- knitr::opts_current$get("comment")
  if( is.na(comment) ) comment <- ""
  can_null <- grepl( paste0( comment, "\\s*\\[\\d?\\]" ),
                     x, perl = TRUE)
  do_null <- isTRUE( knitr::opts_current$get("null_prefix") )
  if( can_null && do_null ) {
    # By default R print output aligns at the left brace.
    align_index <- regexpr( "\\]", x )[1] - 1
    # Two cases: start or newline
    re <- paste0( "^.{", align_index, "}\\]")
    rep <- comment
    x <- gsub( re, rep,  x )
    re <- paste0( "\\\n.{", align_index, "}\\]")
    rep <- paste0( "\n", comment )
    x <- gsub( re, rep,  x )
  }
  
  default_output_hook( x, options )
  
})

knitr::opts_template$set("kill_prefix"=list(comment=NA, null_prefix=TRUE))
```



```{r package, echo=FALSE}
require(psych)
require(psy)
require(corrplot)
require(GPArotation)
require(maptools)
require(NbClust)
require(gplots)
require(spdep)
require(GISTools)
require(cluster)
require(car)
require(RColorBrewer)
require(fpc)
require(cluster.datasets)
require(ggplot2)
library(lattice)
setwd("C:/Users/AlessandraZ/Desktop/Trabalho")
dados <- read.csv("AC1.csv", header = T, dec=".")
rownames(dados) <- dados[,1]
dados <- dados[,-1] 
cidades <- c('Bituruna','Figueira', 'Mirador', 'Colombo', 'Castro', 'Londrina', 'Curitiba')
dados35 <- dados[dados[,6] > 35000, -6] # dados com mais de 35 mil habitantes
data7 <- dados[rownames(dados) %in% cidades,-6] 
```

# Introdução
Para exemplificar algumas funções do pacote *Cluster*, usaremos dados 
de 399 municípios do Paraná. Os municípios serão agrupados de acordo com suas
características socioeconômicas. O pacote contém métodos para análise de Cluster.
 Neste relatório abordamos algumas funções e aplicações que ajudarão a
 entender as funções. 
 Consideramos dois métodos de agrupamento, hierárquico e não hierárquico. 
 


# Materiais e métodos

O relatório foi elaborado no ambiente estatístico R,
 com o uso do pacote *Cluster*. As variáveis presentes neste estudo são
 Índices de Desenvolvimento Humano (IDMH) e Índice Ipardes de Desempenho 
 Municipal (IPDM):
 
 * IDHM_Long: longevidade (referente à esperança de vida ao nascer);
 
 * IDHM_Educ: educação (referente à escolaridade da população adulta frequência escolar);
 
 * Renda_PC: renda familiar per capita;
 
 * IPDM_EmpRenda: índice que se refere à remuneração média do trabalho,
 emprego formal e produção agropecuária;
 
 * IPDM_Saude: índice que se refere ao percentual de mais de seis consultas
 pré-natais por nascido vivo, percentual de óbitos por causas maldefinidas
 e percentual de óbitos de menores de cinco anos por causas evitáveis por
 nascidos vivos.
 
Os dados foram padronizados $Z=\frac{x_{i}-\mu}{\sigma}~N(0,1)$, pois 
nem todas as variáveis estavam numa mesma escala. A média populacional dos 
municípios é de 28 mil habitantes aproximadamente, o município com maior 
número de habitantes é Curitiba com 1.879.355 habitantes, e o menor é 
Jardim Olinda, com 1.409 habitantes. 

Curitiba possui o maior índice de Longevidade (6,33), seguido por Maringá (3,97),
o menor índice é de Doutor Ulysses (-2,02). Em educação, Colombo possui o 
melhor índice (2,36), seguido por Piraquara (2,32), o índice mínimo é de 
Inácio Martins (-2,64). Curitiba e Maringá estão empatados quanto ao índice 
de renda familiar per capita (2,50) e Doutor Ulysses com o menor índice (-3,96).

Curitiba e Araucária possuem o melhor desempenho municipal em emprego
e renda, com os índices 3,67 e 3,23 respectivamente, e Nova Santa Bárbara 
está em última colocação nesta variável. Os municípios com maior desempenho
em saúde são Serranópolis do Iguaçu (2,06) e Rancho Alegre D'Oeste (2,03), 
o menor índice é do município de Novas Laranjeiras (-4,09). 
Curitiba possui índices de 1,65 e 1,15 em educação e saúde respectivamente.

```{r, echo=FALSE}
colnames(dados) <- c("Longevidade","Educacao","RendaPC","EmpRenda","Saude","Populacao")
```

\pagebreak

```{r, echo=FALSE, fig.cap="Gráfico de correlação entre as variáveis", fig.height=3, fig.width=4 }
corrplot.mixed(cor(dados), tl.cex=0.7)
``` 


Para o exemplo com a função de clusterização, separamos apenas 
os 46 municípios com número de habitantes cima de 35 mil, conforme *tabela 1*:
 
```{r, echo=FALSE}
colnames(dados35) <- c("Longevidade","Educação","RendaPC","EmpRenda","Saúde")
kable(head(round(dados35,3)), caption='Descritivas dos 6 primeiros e 6 últimos municípios dos 46 selecionados.')
kable(tail(round(dados35,3)))
```


\pagebreak

# Método hierárquico de agrupamento

Este método monotônico se baseia na realização de sucessivas aglomerações (cada município é um cluster inicialmente) ou de sucessivas divisões dos dados (todos os municípios formam um único cluster).

 Calculamos o agrupamento hierárquico agglomerativo do conjunto de dados com a função *agnes (Agglomerative Nesting with Hierarchical Clustering)*.
 Esta função recebe, de modo geral, uma matriz ou data frame dos dados; 
 o tipo de métrica utilizada para calcular as distâncias entre os municípios
 (euclidian, manhattan, chebyshev e mahalanobis) e o método de clusterização 
 (vizinho mais próximo, vizinho mais distante, distância média, Método de Ward 
 e média ponderada).

 No exemplo a seguir usamos a distância euclidiana entre os municípios$d(x,y)=\sqrt{\sum^{p}_{i=1}(x_{i}-y_{i})^{2}}$ e o método aglomerativo de Ward, que considera o menor acréscimo na soma de quadrados intra-cluster. 

```{r, results='hide'}
clust1 <- agnes(dados35, metric = "euclidean", method = 'ward')
clust1
```

\begin{table}[ht]
\centering
\caption{Ordem dos 46 municípios pelo método Ward de agrupamento.}
\label{my-label}
\begin{tabular}{c|c|c|c}
\hline
{[}01{]}                       & Almirante Tamandaré     & Fazenda Rio Grande       & Paiçandu             \\
{[}04{]}                       & Sarandi                 & Piraquara                & Castro               \\
{[}07{]}                       & Telêmaco Borba          & Santo Antônio da Platina & Guaratuba            \\
{[}10{]}                      & Palmas                  & Prudentópolis            & Cambé                \\
{[}13{]}                      & União da Vitória        & Ibiporã                  & Irati                \\
{[}16{]}                      & São Mateus do Sul       & Campina Grande do Sul    & Colombo              \\
{[}19{]}                      & Lapa                    & Campo Largo              & Foz do Iguaçu        \\
{[}22{]}                      & Jacarezinho             & Guarapuava               & Paranaguá            \\
{[}25{]}                      & Apucarana               & Cianorte                 & Campo Mourão         \\
{[}28{]}                      & Cornélio Procópio       & Dois Vizinhos            & Francisco Beltrão    \\
\multicolumn{1}{l|}{{[}31{]}} & Medianeira              & Toledo                   & Arapongas            \\
\multicolumn{1}{l|}{{[}34{]}} & Rolândia                & Araucária                & São José dos Pinhais \\
\multicolumn{1}{l|}{{[}37{]}} & Marechal Cândido Rondon & Pato Branco              & Pinhais              \\
\multicolumn{1}{l|}{{[}40{]}} & Ponta Grossa            & Paranavaí                & Umuarama             \\
\multicolumn{1}{l|}{{[}43{]}} & Cascavel                & Londrina                 & Maringá              \\
\multicolumn{1}{l|}{{[}46{]}} & Curitiba                &                          &                      \\ \hline
\end{tabular}
\end{table}

A função retorna (em *clust1*) uma lista de componentes. Por padrão é mostrado a ordem das observações, o coeficiente aglomerativo e um resumo descritivo do vetor de distâncias de cada etapa de merge dos clusters. 

Neste caso, a ordem dos municípios é Almirante Tamandaré, Fazenda Rio Grande, 
Paiçandu, ..., Londrina, Maringá e Curitiba, portanto, 
Curitiba é o município mais distante, em similaridade, de Almirante Tamandaré. 
No entanto, a capital é parecida com Londrina, Maringá, Cascavel, entre outros.
O coeficiente de aglomeração (medida de estrutura de cluster): $\frac{1}{n}\sum_{i=1}^{n}(1-m(i))=0.917$, onde $m(i)$ é a distância do i-ésimo elemento ao primeiro cluster que ele é incorporado, dividida pela distância correspondente à junção final do algoritmo $(i=1,2,...,n).$

O dendograma *Figura 1* apenas confirma os resultados já descritos.



\begin{table}[ht]
\centering
\caption{Valores dos merges}
\label{my-label}
\begin{tabular}{c|c|c}
\hline
\multicolumn{1}{l|}{}          & \multicolumn{1}{l|}{{[},01{]}} & \multicolumn{1}{l}{{[}.02{]}} \\ \hline
{[}01,{]}                      & -13                            & -15                           \\
{[}02,{]}                      & -7                             & -17                           \\
{[}03,{]}                      & -2                             & -11                           \\
{[}04,{]}                      & -8                             & 1                             \\
{[}05,{]}                      & -32                            & -45                           \\
...                            & ...                            & ...                           \\
\multicolumn{1}{l|}{{[}45,{]}} & 43                             & 44                            \\ \hline
\end{tabular}
\end{table}

As distâncias a que os indivíduos se juntam pela
primeira vez para formar grupo (conforme o método de sucessivas aglomerações) os valores da altura (height) de cada município, e o grau de dissimilaridade entre os municípios estão na *tabela 4, 5 e 6*
respectivamente. A altura é representada no dendograma no eixo y. A maior altura (4,102) é de Curitiba.

\begin{table}[ht]
\centering
\caption{Valores de height}
\label{my-label}
\begin{tabular}{ccccccccccc}
\hline
\multicolumn{1}{c|}{{[}01{]}} & \multicolumn{1}{c|}{{[}02{]}} & \multicolumn{1}{c|}{{[}03{]}} & \multicolumn{1}{c|}{{[}04{]}} & \multicolumn{1}{c|}{{[}05{]}} & \multicolumn{1}{c|}{}       & \multicolumn{1}{c|}{{[}41{]}}   & \multicolumn{1}{c|}{{[}42{]}} & \multicolumn{1}{c|}{{[}43{]}} & \multicolumn{1}{c|}{{[}44{]}} & {[}45{]} \\ \hline
\multicolumn{1}{c|}{0.7619}   & \multicolumn{1}{c|}{0.9959}   & \multicolumn{1}{c|}{1.1845}   & \multicolumn{1}{c|}{2.0199}   & \multicolumn{1}{c|}{3.9067}   & \multicolumn{1}{c|}{...}    & \multicolumn{1}{c|}{0.6317}     & \multicolumn{1}{c|}{6.9137}   & \multicolumn{1}{c|}{1.0180}   & \multicolumn{1}{c|}{1.6745}   & 4.1022   \\ \hline
                              &                               &                               &                               &                               &                             &                                 &                               &                               &                               &          \\ \cline{3-8}
                              &                               & \multicolumn{6}{c}{Resumo de Height}                                                                                                                                                          &                               &                               &          \\ \cline{3-8}
                              &                               & \multicolumn{1}{c|}{Min.}     & \multicolumn{1}{c|}{1º Quartil}  & \multicolumn{1}{c|}{Mediana}  & \multicolumn{1}{c|}{Média}  & \multicolumn{1}{c|}{3º Quartil} & Máx.                          &                               &                               &          \\ \cline{3-8}
                              &                               & \multicolumn{1}{c|}{0.3663}   & \multicolumn{1}{c|}{0.8403}   & \multicolumn{1}{c|}{1.2196}   & \multicolumn{1}{c|}{1.9921} & \multicolumn{1}{c|}{2.0920}     & 12.7977                       &                               &                               &          \\ \cline{3-8}
\end{tabular}
\end{table}

Grande dissimilaridade entre grupos, isso pode ser referido como separação externa (ou isolamento).

\begin{table}[ht]
\centering
\caption{Dissimilaridade}
\label{my-label}
\begin{tabular}{lccccccc}
\hline
\multicolumn{1}{c|}{}                 & \multicolumn{1}{c|}{Alm. Tamandaré} & \multicolumn{1}{c|}{Apucarana} & \multicolumn{1}{c|}{Arapongas} & \multicolumn{1}{c|}{Araucária} & \multicolumn{1}{c|}{...}       & \multicolumn{1}{c|}{Toledo}    & Umuarama             \\ \hline
\multicolumn{1}{l|}{Apucarana}        & \multicolumn{1}{c|}{2.8705398}      & \multicolumn{1}{c|}{}          & \multicolumn{1}{c|}{}          & \multicolumn{1}{c|}{}          & \multicolumn{1}{c|}{}          & \multicolumn{1}{c|}{}          &                      \\ \hline
\multicolumn{1}{l|}{Arapongas}        & \multicolumn{1}{c|}{3.1541769}      & \multicolumn{1}{c|}{1.2905717} & \multicolumn{1}{c|}{}          & \multicolumn{1}{c|}{}          & \multicolumn{1}{c|}{}          & \multicolumn{1}{c|}{}          &                      \\ \hline
\multicolumn{1}{l|}{Araucária}        & \multicolumn{1}{c|}{3.9446129}      & \multicolumn{1}{c|}{2.1660205} & \multicolumn{1}{c|}{1.5605966} & \multicolumn{1}{c|}{}          & \multicolumn{1}{c|}{}          & \multicolumn{1}{c|}{}          &                      \\ \hline
\multicolumn{1}{l|}{Cambé}            & \multicolumn{1}{c|}{2.2633494}      & \multicolumn{1}{c|}{0.8268983} & \multicolumn{1}{c|}{1.6848378} & \multicolumn{1}{c|}{2.5876438} & \multicolumn{1}{c|}{}          & \multicolumn{1}{c|}{}          &                      \\ \hline
\multicolumn{1}{c|}{...}              & \multicolumn{1}{c|}{}               & \multicolumn{1}{c|}{}          & \multicolumn{1}{c|}{}          & \multicolumn{1}{c|}{}          & \multicolumn{1}{c|}{}          & \multicolumn{1}{c|}{}          &                      \\ \hline
\multicolumn{1}{l|}{Umuarama}         & \multicolumn{1}{c|}{2.9704764}      & \multicolumn{1}{c|}{1.5288438} & \multicolumn{1}{c|}{0.9937417} & \multicolumn{1}{c|}{2.3684320} & \multicolumn{1}{c|}{...}       & \multicolumn{1}{c|}{1.6499626} &                      \\ \hline
\multicolumn{1}{l|}{União da Vitória} & \multicolumn{1}{c|}{2.3768114}      & \multicolumn{1}{c|}{1.1980550} & \multicolumn{1}{c|}{1.5090229} & \multicolumn{1}{c|}{2.5004803} & \multicolumn{1}{c|}{...}       & \multicolumn{1}{c|}{2.1473200} & 1.5558991            \\ \hline
                                      & \multicolumn{1}{l}{}                & \multicolumn{1}{l}{}           & \multicolumn{1}{l}{}           & \multicolumn{1}{l}{}           & \multicolumn{1}{l}{}           & \multicolumn{1}{l}{}           & \multicolumn{1}{l}{} \\ \cline{2-7}
                                      & \multicolumn{6}{c}{Resumo das dissimilaridades}                                                                                                                                                          & \multicolumn{1}{l}{} \\ \cline{2-7}
                                      & \multicolumn{1}{c|}{Mín.}           & \multicolumn{1}{c|}{1ºQuartil} & \multicolumn{1}{c|}{Mediana}   & \multicolumn{1}{c|}{Média}     & \multicolumn{1}{c|}{3ºQuartil} & Máx.                           & \multicolumn{1}{l}{} \\ \cline{2-7}
                                      & \multicolumn{1}{c|}{0.3663}         & \multicolumn{1}{c|}{1.6386}    & \multicolumn{1}{c|}{2.2791}    & \multicolumn{1}{c|}{2.5829}    & \multicolumn{1}{c|}{3.2037}    & 9.2095                         & \multicolumn{1}{l}{} \\ \cline{2-7}
\end{tabular}
\end{table}



É possível visualizar o vetor de distâncias a cada inclusão no cluster com *height*, 
os merges dos clusters em cada etapa *merge*, a matriz de dissimilaridade 
do conjunto de dados *diss*, e a matriz dos dados originais 
ou padronizadas (dependendo do *scale* da função) com *data*. 



```{r, echo=FALSE, fig.height=7, fig.width=7, fig.cap='Dendograma dos 46 municípios - método de Wald'}
plot(clust1, which.plot = 2)
```

Quando mudamos o método de aglomeração de Ward para os seguintes métodos: vizinho 
mais distante, vizinho mais próximo, distância média e média ponderada, o
coeficiente aglomerativo descresce de 0.92 para 0,88, 0,65, 0,83 e 0,84 respectivamente. E Curitiba passa a ficar isolada em um cluster. (*figura 3*)

```{r, echo=FALSE, fig.height=10, fig.width=12, fig.cap="Comparação dos métodos de aglomeração para os 46 municípios"}
clust3 <- agnes(dados35, metric = "euclidean", method = 'complete')
clust4 <- agnes(dados35, metric = "euclidean", method = 'single')
clust5 <- agnes(dados35, metric = "euclidean", method = 'average')
clust6 <- agnes(dados35, metric = "euclidean", method = 'weighted')

par(mfrow=c(2,2))
plot(clust3, which.plot = 2, main="Vizinho mais distante")
plot(clust4, which.plot = 2, main="Vizinho mais próximo")
plot(clust5, which.plot = 2, main="Distância média")
plot(clust6, which.plot = 2, main="Média ponderada")
```


O heatmap (*figura 4*) representa os valores dos dados socioeconômicos para 
cada um dos municípios. As cores são representadas pelo escore $Z={(x-\mu)}{\sigma}$, e variam do amarelo (escore baixo) ao vermelho (escore
alto). Curitiba possui escore próximo a 4 em longevidade e Piraquara possui escore
elevado para educação, conforme vimos na análise descritiva. O heatmap
é uma forma de visualizar pontos socioeconômicos fortes e fracos de cada municípios, além de adicionar um dendograma pelo método de Ward. Com o histograma na legenda de cores do gráfico, visualizamos a concentração de escores próximos a zero.

```{r, echo=FALSE, fig.height=8, fig.width=10, fig.cap="Mapa de calor dos 46 municípios"}
heatmap.2(as.matrix(dados35), Rowv = TRUE, dendrogram = 'row', col=rev(heat.colors(10)),
          scale = 'col', margin=c(6, 10), cexRow = 1, cexCol = 1, tracecol = 'black',
          hclustfun = function(x) hclust(x,method = 'ward.D2'))
```

No eixo x do bannerpot (*figura 5*) aparecem as alturas e no eixo y os municípios 
que serão agrupados. O espaço em branco indica separação entre os municípios. As outras barras 
vermelhas indicam o agrupamento.


```{r, echo=FALSE, fig.height=8, fig.width=10, fig.cap="Bannerplot"}
bannerplot(agnes(dados35, metric = "euclidean", method = 'ward'))
```

A função *fanny* calcula uma aglomeração fuzzy em k clusters, onde um município é associado a todos os clusters através da variação do grau de pertinência (função mais complexa que $L^{2}$ e euclidiana) do município em cada cluster. As vantagens do *fuzzy* é que este pode representar melhor incerteza, podendo mostrar que um município não é um 
típico município de nenhuma das classes, mas tem similaridade em maior ou menos grau com mais de uma classe. 

```{r, echo=FALSE, fig.height=10, fig.width=12, fig.cap="Fuzzy plot com gráfico de silhueta"}
f4 <- fanny(dados35, 3)
#summary(f4)
#stopifnot(rle(f4$clustering)$lengths == c(1,3,1,1,1,2,1,1,1,3,1,1,1,1,3,1,1,4,2,2,2,1,1,1,1,1,1,2,1,2,1))
plot(f4, which = 1)
## Plot similar to Figure 6 in Stryuf et al (1996)
plot(fanny(dados35, 4))
# Fuzzy: associa a cada cluster uma "probabilidade" de associação.
# "É possível observar o comportamento (decaimento) do erro associado a clusterização e também a disposição dos fatores em relação ao cluster.
```


## Análise com todos os municípios 

Consideramos agora todos os 399 municípios, ainda com o método de ward e 
distância euclidiana. Porém, consideramos 6 clusters, um dos clusters contém apenas
Curitiba. Agora a capital está mais próxima dos municípios de Nova Londrina, 
Jaguariaíva e Rio Negro e mais distante de Abatiá e São João do Ivaí. Para representação dos 
clusters no dendograma, foi cortado a altura 4 (height=4), para melhorar a visualização.

```{r, fig.height=8, fig.width=14, echo=FALSE, fig.cap="Dendograma com seis ramos para todos os municípios, podado na altura h=12"}
dataall <- dados[, -6]
clustall <- agnes(dataall, metric = "euclidean", method = 'ward')
dend <- as.dendrogram(clustall)
plot(cut(dend, h=12)$lower[[6]], 
     main=" ")
```



```{r, echo=FALSE, fig.height=6, fig.cap="Mapa"}
# indcluster <- cutree(clustall, 6); indcluster #vetor com os índices dos grupos aos quais cada município foi alocado.
# indclusterord <- recode(indcluster, "1 = 2 ; 2 = 3 ; 3 = 1") #Re-ordenação dos labels 
# error.bars.by(dataall, indclusterord, bars = TRUE, colors = c('white', 'yellow', 'orange', 'red', 'black'),
#               labels = paste('Cluster ', 1:6), legend = 5, 
#               v.labels = c("IDHM_Long","IDHM_Educ","Renda_PC","IPDM_EmpRenda","IPDM_Saude"),
#               ylab = 'Médias')
# 
# colors <- brewer.pal(6, "YlOrRd") ### Definindo uma paleta de cores com seis cores.
# 
# setwd("C:/Users/AlessandraZ/Desktop/Trabalho")
# parana <- readShapePoly("Mapa/41mu2500gsr")
# plot(parana, col = colors[indclusterord], main = 'Distribuição espacial dos clusters formados')
# 
# legend(x=-49, y=-23, legend=1:6, fill=colors, bty="n",
#        x.intersp = 1, y.intersp = 1, title = 'Cluster')
# coord1 <- coordinates(parana)[,1] ### Vetor de longitudes.
# coord2 <- coordinates(parana)[,2] ### Vetor de latitudes.
# ic <- which(parana$NOME_MUNIC %in% cidades)
# text(x = coord1[ic], y = coord2[ic], parana$NOME_MUNIC[ic])
```



```{r, echo=FALSE, fig.height=6, fig.cap="Mapa por mesorregião"}
# mesoreg <- parana$NOME_MESO; 
# head(mesoreg)
# 
# colors <- brewer.pal(10, "BrBG")
# plot(parana, col = colors[mesoreg], main = 'Paraná - Mesorregiões')
# 
# legend(x=-49, y=-23, legend=levels(mesoreg), fill=colors, bty="n",
#        x.intersp = 1, y.intersp = 1, title = 'Cluster')
```

```{r, echo=FALSE, fig.height=6, fig.cap="Gráfico de mosaico"}
# t1 <- table(mesoreg, indclusterord); t1  ### Tabela de freqwuências: mesorregião vs clusters.        
# p1 <- prop.table(t1, 1); p1 ### Tabela de frequências relativas.
# t(apply(p1, 1, cumsum)) ### Tabela de frequências relativas acumuladas.
# rownames(t1) <- c('C-S', 'C-Oc', 'C-Or', 'Met', 'Nord', 'Nte-Cto',
#                   'Nte-Pio', 'Oeste', 'SE', 'SO')
#mosaicplot(t1, shade = TRUE, legend = TRUE)
```


Diferentes cenários para o coeficiente aglomerativo para análise de cluster de 6 municípios.

- Primeiro cenário: contém os municípios de Mariluz, Tuneiras do Oeste, Alto Paraná, Paula Freitas, Jardim Olinda e Quatiguá.
- Segundo cenário: São Jorge do Ivaí, Santa Fé, Laranjal, Pinhalão, Siqueira Campos e Diamante do Sul
- Terceiro cenário: Guaíra, Chopinzinho, Guaraci, Lapa, Campo Magro e Francisco Alves
- Quarto: Paranapoema, Barracão, Laranjeiras do Sul, Jundiaí do Sul, Nova Esperança, Tomazina

Comparando os dendogramas dos cenários 1 e 2 (*figura 10*), vemos uma diferença de altura mínima entre os municípios, resultando em um coeficiente aglomerativo baixo e um bannerplot (*figura 12*) sem divisão aparente.
Os dendogramas dos cenários 3 e 4 (*figura 11*) há uma diferença grande nas alturas dos agrupamentos, e
coeficientes aglomerativos altos (0,81 e 0,95) com uma divisão aparente no bannerplot.

```{r, echo=FALSE, fig.height=3, fig.width=7, fig.cap="Comparando coeficientes para diferentes cenarios (1 e 2)"}
limit3 <- 65000

par(mfrow = c(1,2))

cidades6_1 <- c("Mariluz","Tuneiras do Oeste","Alto Paraná","Paula Freitas","Jardim Olinda","Quatiguá")
data6_1 <- dados[cidades6_1,]
clust6_1 <- agnes(data6_1, metric = "euclidean", method = 'ward')
plot(as.dendrogram(clust6_1), ylim = c(0,limit3), main = 'Cenario 1 - Coef = 0.550')

cidades6_2 <- c("São Jorge do Ivaí","Santa Fé","Laranjal","Pinhalão","Siqueira Campos","Diamante do Sul")
data6_2 <- dados[cidades6_2,]
clust6_2 <- agnes(data6_2, metric = "euclidean", method = 'ward')
plot(as.dendrogram(clust6_2), ylim = c(0,limit3), main = 'Cenario 2 - Coef = 0.721')
```


```{r, echo=FALSE, fig.height=3, fig.width=7, fig.cap="Comparando coeficientes para diferentes cenarios (3 e 4)"}
par(mfrow = c(1,2))

cidades6_3 <- c("Guaíra","Chopinzinho","Guaraci","Lapa","Campo Magro","Francisco Alves")
data6_3 <- dados[cidades6_3,]
clust6_3 <- agnes(data6_3, metric = "euclidean", method = 'ward')
plot(as.dendrogram(clust6_3), ylim = c(0,limit3), main = 'Cenario 3 - Coef = 0.807',las=1)

cidades6_4 <- c("Paranapoema","Barracão","Laranjeiras do Sul","Jundiaí do Sul","Nova Esperança","Tomazina")
data6_4 <- dados[cidades6_4,]
clust6_4 <- agnes(data6_4, metric = "euclidean", method = 'ward')
plot(as.dendrogram(clust6_4), ylim = c(0,limit3), main = 'Cenario 4 - Coef = 0.946')
```


````{r, echo=FALSE,  fig.height=6, fig.width=6, fig.caption="Bannerplot para cada cenario"}
par(mfrow = c(2,2), mar = c(7,5,4,2), las = 1)

plot(clust6_1, which = 1, main = 'Cenário 1')
plot(clust6_2, which = 1, main = 'Cenário 2')
plot(clust6_3, which = 1, main = 'Cenário 3')
plot(clust6_4, which = 1, main = 'Cenário 4')
```


# Método não-hierárquico de agrupamento

Até agora vimos apenas método aglomerativo hierárquico com funções como hclust. 
Agora veremos métodos de particionamento, onde assumimos um número pré-determinado de
aglomerados k.
Usaremos as funções *kmeans* e *pam* (partitioning around medoids).

A função *cluster.stats*, do pacote *fpc*, fornece um grande número de
estatísticas que podem ser usadas para validar o resultado da análise de
cluster e escolher o número de clusters a ser usado. Vamos usar uma delas.

Calinski-Harabasz statistic (CH):

$$CH = (n-k)*tr(B)/((k-1)*tr(W))$$

Sendo,

- *W* a matriz de somas de quadrados e produtos cruzados INTRA-cluster,
- *B* a matriz de somas de quadrados e produtos cruzados ENTRE clusters.

Podemos calcular o valor de CH para uma sequência crescente de valores 
de k, e escolher o número de grupos (k) tal que CH seja máximo.

Usando a estatistica de Calinski-Harabasz para efeito de determinar o
número de clusters para o problema dos carros.

A solução com quatro clusters produz maior valor para o índice, dentre 
as nove soluções consideradas. É a melhor opção. A solução com k=2 clusters 
produziu maior valor para a estatística, esta seria a indicação do método.

````{r, echo=FALSE}
dados <- dados[,-c(1,7)] # dados sem o nome do municipio e sua população
```


Vamos usar a função *nbClust*, do pacote *nbclust*, para verificar o melhor número de 
cluster segundo diferentes índices.


Agora, o método k-means aplicado à base do Paraná. Iniciemos com a avaliação
do número de clusters, resgatando o método hierárquico de ward.
Com os gráficos para o número de clusters *fugura 13* e o gráfico de barras *figura 14*, 
as melhores quantidades de clusters são 2, 3, 4 e 6.
```{r nclu, echo=FALSE, fig.width=8, fig.cap="Número de clusters"}
ncluster <- NbClust(data = dados, distance = "euclidean", min.nc=2, max.nc=10,
                    method = "ward.D2")

indices <- ncluster$All.index; indices ### Relação de índices, para valores de 
### k entre 2 e 8. 

k <- ncluster$Best.nc[1,] ### Para cada método, o número 'ótimo' de clusters.
```

```{r, fig.cap="Barplot para número de clusters e índices"}
barplot(table(k), xlab = 'Número de clusters', ylab = 'Número de índices')
### A maior parte dos índices apontando para k=3 e k=2, com quatro índices
### apontando para k=5 clusters.
```

```{r, fig.cap="Dendograma", echo=FALSE}
#plot(hclust(dist(dados), method = 'ward.D2'))
```


## Método 1 - Duas aplicações considerando sementes selecionadas ao acaso, sem repetição.

```{r means, echo=FALSE}
set.seed(25)
kmeanspar1 <- kmeans(dados, centers = 6, nstart = 1)

set.seed(38)
kmeanspar2 <- kmeans(dados, centers = 6, nstart = 1)

t1 <- table(kmeanspar1$cluster, kmeanspar2$cluster)
kable(t1)
```


Num cenário ideal extremo, teríamos apenas 6 frequências não nulas nessa
tabela, refletindo que todos os indivíduos alocados a um particular cluster
na primeira aplicação, compõem o mesmo cluster na segunda. O fato de termos
dez frequências não nulas (com no mínimo 14 municípios cada) reflete discordância
entre os resultados.


## Método 2 - Agora, duas aplicações com sementes arbitrárias, mas com m=20 repetições cada.
 
```{r menas, echo=FALSE}
set.seed(52)
kmeanspar3 <- kmeans(dados, centers = 6, nstart = 20)

set.seed(12)
kmeanspar4 <- kmeans(dados, centers = 6, nstart = 20)

t2 <- table(kmeanspar3$cluster, kmeanspar4$cluster)
kable(t2)
```

Observe que agora não há discordância na constituição dos clusters.

## Método 3 - Escolhendo como sementes um município de cada cluster gerado pelo método hierárquico.




```{r, echo=FALSE}
h1 <- agnes(dados, metric = 'euclidean', method = 'ward')
k6 <- cutree(h1,6);
k6split <- split(row.names(dados), k6); 


cidades1 <- c('Ibema', 'Antonina', 'Cerro Azul', 'Mallet', 'Marialva', 'Palotina' )
cidades2 <- c('Planalto', 'Palmas', 'Laranjal', 'Juranda', 'Terra Roxa', 'Londrina')

kmeanspar5 <- kmeans(dados, centers = dados[cidades1,])
kmeanspar6 <- kmeans(dados, centers = dados[cidades2,])

t3 <- table(kmeanspar5$cluster, kmeanspar6$cluster)
kable(t3)

### Pequenas discordâncias.
```


## Caso extremo - Escolhendo como sementes seis municípios de um mesmo cluster gerado pelo método hierárquico.

```{r mena2s, echo=FALSE}
cidades3 <- sample(k6split[[1]],6)
cidades4 <- sample(k6split[[1]],6)

kmeanspar7 <- kmeans(dados, centers = dados[cidades3,])
kmeanspar8 <- kmeans(dados, centers = dados[cidades4,])

t4 <- table(kmeanspar7$cluster, kmeanspar8$cluster)
kable(t4)

### Grandes discordâncias.
```` 

## Método 3 - Escolhendo como sementes as médias dos clusters gerados pelo método hierárquico.

```{r menas3, echo=FALSE}
medias <- aggregate(dados, list(k6), mean)
kmeanspar9 <- kmeans(dados, centers = medias[,-1])

clustkmeans <- kmeanspar9$cluster
kable(table(k6, clustkmeans))
### Repare que o algoritmo k-means produz re-alocações em alguns clusters produzidos pelo método hierárquico.
```

# Comparação

```{r, echo=FALSE,  fig.width=6}
par(mfrow = c(1,2),cex = 0.7)

s2 <- silhouette(k6, dist(dados), main = 'Hierárquico')
plot(s2, ylim=c(0,100), main = 'Hierárquico')
s1 <- silhouette(clustkmeans, dist(dados), main = 'Hk-means')
plot(s1,ylim=c(0,100), main = 'Hk-means')
````

